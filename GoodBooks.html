<html><meta charset="UTF-8"><title>GoodBooks_moverzp</title><body><h2><a href='https://book.douban.com/subject/1477390/' target=_blank>代码大全（第2版）</a></h2><table border="1"><tr><td>评分：</td><td><b> 9.3 </b></td></tr><tr><td>作者：</td><td>[美] 史蒂夫·迈克康奈尔</td></tr><tr><td>定价：</td><td> 128.00元</td></tr><tr><td>出版社：</td><td> 电子工业出版社</td></tr><tr><td>出版时间：</td><td> 2006-3</td></tr><tr><td>ISBN：</td><td>9787121022982</td></tr></table><p><h3>简介：</h3>第2版的《代码大全》是著名IT畅销书作者史蒂夫·迈克康奈尔11年前的经典著作的全新演绎：第2版不是第一版的简单修订增补，而是完全进行了重写；增加了很多与时俱进的内容。这也是一本完整的软件构建手册，涵盖了软件构建过程中的所有细节。它从软件质量和编程思想等方面论述了软件构建的各个问题，并详细论述了紧跟潮流的新技术、高屋建瓴的观点、通用的概念，还含有丰富而典型的程序示例。这本书中所论述的技术不仅填补了初级与高级编程技术之间的空白，而且也为程序员们提供了一个有关编程技巧的信息来源。这本书对经验丰富的程序员、技术带头人、自学的程序员及几乎不懂太多编程技巧的学生们都是大有裨益的。可以说，无论是什么背景的读者，阅读这本书都有助于在更短的时间内、更容易地写出更好的程序。</p><p><h3>热评：</h3><span class="" property="v:description">啊，也不知道多少天了，终于啃完了大部头Code Complete。经典就是经典，确实受益匪浅。<br> <br>总结一下，其实让我记忆深刻的主要是两点：<br> <br>首先，软件构建的核心就是管理复杂度。虽然书中有不少的篇幅来讨论变量、语句等等这些编程的基本要素，还包括代码改善和调整的策略和方法，可谓不无巨细。不过深入理解一下，这些内容都是围绕着上面这句话展开的，也就是软件构建的核心就是管理复杂度。而这一目标产生的根源就在于人脑智力同软件项目复杂程度之间的矛盾。书中常常会提到几个数字，差不多在6、7左右变化，因为这是人脑智力管理的极限，多了，就管不过来了，呵呵。所以，书中会有一些结论性的建议。比如构建可工作的类，内部成员应该控制在7(+-)2，也就是5个或者9个左右，如果都是Native Type的话，9个成员变量能管的过来，如果都是对象成员的话，5个也能保证你的头脑始终清晰。还有，比如程序中的嵌套结构，类似于If，循环啊什么的，要保持嵌套层次不能多于6层，而据实际调查，一般3层以上的嵌套就会使程序员非常的困惑和抓狂了；还有比如子程序的参数个数尽量保持在7个以下，要不然也记不住，别说7个了，没有现代IDE的帮助，我连4个以上的参数我都记不住，呵呵。<br> <br>我想满足这些指标并不是很难的事情，而这些东西也给出了对于代码进行改善时候可以依据的标准。不过想要管理这种复杂度，从作者的书中总结一下，具体可能是以下几点：第一，分割，既然大脑管不过来，那就把系统进行分割，也就是从设计角度上抽象出若干部分，每次让大脑focus在一个部分上，这点我是有深刻体会，虽然我现在完全自己做的东西超不过15000行，不过也不能妄想自己把所有的部分都记住，如果抽象的不好的话，我就特别头疼，每天在代码中翻来翻去的，效率非常低；第二，清晰理解，其实这点跟上面一点是差不多的，只有清晰理解了抽象的含义，才能做好每个封装每个接口，这样在关注别的抽象部分的时候，其他部分需要记住和管理的更清晰也更简洁，因为不需要关注其他部分是如何实现的，只要按照接口和抽象来做就好了；第三，清晰表达，在程序中应该清晰表达逻辑和抽象含义，也就是增加程序的可读性，唉，这点太重要了，书上也围绕着这个不断的论述，上面提到那些事无巨细的部分反复的说着这一点，甚至连命名都有专门的一章来讨论。<br> <br>第二点我觉得记忆深刻的就是：以程序员为本。可惜国内的我见过的企业做不到这些。其实以程序员为本不是说一个公司的文化，也不是说单纯就是项目管理人员的事情，其实，最底层的程序员也应当遵从这一条。代码首先是为了人而写的，不是为了机器。机器只会对机器码感兴趣，高级语言自然是留给人来看的。所以说，即便是最底层的程序员也应当奉行这一条，合作中更讲究这个。呵呵，话题又回到了上面提过的可读性的问题。当然，以程序员为本也可以延伸到企业文化或者项目组文化，毕竟在这个过程中，程序员追求的技术满足程度外行可能无法理解，不过理解起来也很容易，就像画家对于自己的油画，建筑师对于自己的建筑那种感觉。<br> <br>“Programming is neither fully an art nor fully a science. As it's typically practiced, it's a "craft" that's somewhere between art and science. At its best, it's an engineering discipline that arises from the synergistic fusion of art and science.”现在我的理解，恰恰是这种艺术与科学相互融合的产物带给程序员无比的满足感。<div class="clear"></div></span></p><hr><h2><a href='https://book.douban.com/subject/1052241/' target=_blank>设计模式</a></h2><table border="1"><tr><td>评分：</td><td><b> 9.1 </b></td></tr><tr><td>作者：</td><td>[美] Erich Gamma</td></tr><tr><td>定价：</td><td> 35.00元</td></tr><tr><td>出版社：</td><td> 机械工业出版社</td></tr><tr><td>出版时间：</td><td> 2000-9</td></tr><tr><td>ISBN：</td><td>9787111075752</td></tr></table><p><h3>简介：</h3>这本书结合设计实作例从面向对象的设计中精选出23个设计模式，总结了面向对象设计中最有价值的经验，并且用简洁可复用的形式表达出来。书中分类描述了一组设计良好、表达清楚的软件设计模式，这些模式在实用环境下特别有用。此书适合大学计算机专业的学生、研究生及相关人员参考。</p><p><h3>热评：</h3><span class="" property="v:description">作者坦言，书中描述的23种模式并不是他们创造出来的，他们只是进行了总结和归纳。<br><br>这本书并不适于初学编程的人，甚至是没有相关知识背景的熟练程序员。因为其对概念的描述太过简洁和学术化，其C++的例子也不是很好懂--我自己就愣是没有看懂，后来还是通过另一本以Java为例子的书来帮助理解的。<br><br>我以为学设计模式，切不可太生搬硬套--这是初学者常犯的毛病。而应该更深入的理解其内涵，更多的研读现实中成功产品的源代码，以理解这些模式是如何实际应用的。<br><br>设计模式并不是什么新的东西。有些模式，你或许已经在实际项目中应用了很多年了，只是不知道人家原来是这么称呼它的！<br><br>所以，这本书最大的贡献应该是统一了术语，从此全世界的圈内人士交流再无障碍，GOF一词也因此成为了经典。<br><br><div class="clear"></div></span></p><hr><h2><a href='https://book.douban.com/subject/1467587/' target=_blank>UNIX编程艺术</a></h2><table border="1"><tr><td>评分：</td><td><b> 9.0 </b></td></tr><tr><td>作者：</td><td>Eric S. Raymond</td></tr><tr><td>定价：</td><td> 59.00元</td></tr><tr><td>出版社：</td><td> 电子工业出版社</td></tr><tr><td>出版时间：</td><td> 2006-2</td></tr><tr><td>ISBN：</td><td>9787121021169</td></tr></table><p><h3>简介：</h3>本书主要介绍了Unix系统领域中的设计和开发哲学、思想文化体系、原则与经验，由公认的Unix编程大师、开源运动领袖人物之一Eric S. Raymond倾力多年写作而成。包括Unix设计者在内的多位领域专家也为本书贡献了宝贵的内容。本书内容涉及社群文化、软件开发设计与实现，覆盖面广、内容深邃，完全展现了作者极其深厚的经验积累和领域智慧。</p><p><h3>热评：</h3><span class="" property="v:description">本文同步发于我的blog: <a href="http://www.vingel.com" rel="nofollow" target="_blank">http://www.vingel.com</a><br><br>这本书我已经买了三个星期，一直在看。以前看它的英文版，仅仅走马观花般看了一遍。现在这个中文版，目前为止我已经看了三遍，而每次都会有新的体会。我得到的关于《Unix编程艺术》最深的感想就是：Unix中无所不在的K.I.S.S(Keep It Simple, Stupid)原则。<br><br>显然，Unix的设计中贯彻了这个原则，而且连Unix下的软件也深刻地受到这个原则的影响。比如ed,head这些<br>小程序。《注重实效的程序员》中也提到过著名的Unix哲学:“提供锋利的小工具，其中每一样都意在吧每一件事情做好。Unix因围绕这样的哲学进行设计而著称。”<br><br>另外，Eric还另外阐述了Linux开发原则(这个原则他在《大教堂与市集》一文中说过)，”如果有足够的眼睛关注，那么所有的bug将无处藏身。”<br><br>还有，该书附录D中的《无根的根:无名师的Unix心传》很有意思啊，该附录模仿中国的禅宗故事，写下了关于Unix的传说。这些故事与Jargon File中提到的相映成趣，原来Hacker们也很搞笑有趣的。<br>摘录一个故事如下：<br><br>    《无名师与方法论》<br>    无名师和学生Nubi在圣地行走，无名师习惯在晚间为城市和乡村的Unix新门徒布道。<br><br>    一次，聆听者中混入了一名方法论者。<br><br>    “优化程序时不对热点进行反复衡量，就像渔夫把网撒入空湖中。”无名师说。<br><br>    “那么，”方法论者说，”管理资源时不持续地衡量你的产能，不也像渔夫将网撒入空湖中么？”<br><br>    “我一次碰到一个渔夫时，他正将网撒入船下的湖中，”无名师说，”他摸了好一会儿船底，像在寻找他的船。”<br><br>    “但是，”方法论者说，”如果他把网撒入湖中，为什么他还要找船呢？”<br><br>    “因为他不会游泳.”无名师答道。<br><br>    听到这，方法论者眼中一亮。<br><br>怎么样，你能否猜出是模仿自哪个禅宗故事吗？<div class="clear"></div></span></p><hr></body></html>